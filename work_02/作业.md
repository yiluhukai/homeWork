-   一.输出结果为 10,数组中每个元素都引用了 for 循环的函数，这些函数形成了闭包，变量被这些函数包裹循环体中的变量 i 到自己的作用域链上，
    当我们执行这个函数的时候，循环已经执行完成，变量 i 变成了 10.所以打印的是 10.

-   二、let 声明的变量不会发生声明提前，所以当我们访问这个 temp 时，访问的时外部的 temp 变量，所以输出 123

-   三、

```js
var arr = [12, 34, 32, 89, 4]
arr.sort((a, b) => a - b)[0]
```

-   四、1.var 声明的变量是函数作用域，而 let、const 声明的变量是块级作用域
    2.var 声明的变量会存在声明提前，而 let 和 const 声明的变量在声明之前位于临时死区中，甚至不能通过 typeof 去探测
    3.var 声明的变量可以重复声明，但是 let 和 const 不可以
    4.var 声明的全局变量会变成全局对象的属性，但是 let 和 const 声明的变量不会
    5.let 和 const 的区别主要在于 const 声明的变量是个常量，变量不可以里保存的值不能被修改，所以需要初始化，由于变量为引用类型
    时，变量里存放是引用地址，我们不可以修改这个地址，但是地址里面的对象还是可以修改的，所以可以给对象添加属性等

-   五，最终输出 20，由于使用了箭头函数，箭头函数的没有 this,所以使用 this 会在当前函数的作用域链的上一层去查找，上一层的 thsi 是当前对象，
    所以结果是对象的 a 属性
-   六、1.对象的属性可以 symbol 类型的，而 symbol 类型只能通过变量去访问，基于此我们可以使用它为对象创建私有属性。

    2.  同时 ES6 中为我们提供了一些 well-known 的 Symbol 属性，我们可以用他为对象为对象添加新的特性，如使对象变成可迭代对象。

-   七、深拷贝和浅拷贝
    深拷贝指的是我们拷贝对象的时候会把对象的所有属性都复制过去，当对象的属性属性是引用类型的时候，会生成一个新的对象而不是使用原来的对象。
    浅拷贝指的是复制对象的属性值，当属性值为引用是，新复制的对象和原来的对象引用的是同一个对象。
-   八、 TS 是 JS 的超集，TS 约等于 JS + ES6+ +类型系统
-   九、 优点：首先解决掉了 JS 糟糕的类型系统的问题，其次支持 ES6 的语法，还有他的渐进式设计，可以很容易将 JS 项目过度到 TS.
    缺点：在 JS 的继承之上引入了新的概念，如接口、枚举等，增加了学习成本
    在小项目中使用会增加开发的成本
-   十、引用计数通过为对象设置引用计数器，当引用为了 0 是就会被 GC 回收，优点是回收的比较及时，减少程序暂停
    缺点是：时间开销大(要不断的去检测引用数的变化)，无法回收循环引用的对象
-   十一、1.标记清除算法分标记和清除两个阶段完成 2. 遍历所有对象去找活动对象(可达对象) 3.遍历所有对象去清除没有标记的对象，将所有清除对象的内存释放并放入空闲链表中，方便下次直接使用
    优点是可以发现循环引用的不可达对象并回收
    缺点是:会造成内存空间碎片,回收后的空间在内存中可能不连续且大小不固定，我们下次要分配的空间不一定满足。不可以立即回收内存空间
-   十二、回收中采用复制算法+标记整理算法，新生代区域被分成两个等大小的部分 From 和 To，活动对象存储于 From 区域，标记整理完成后会将 From 中的对象复制到 To 中
    From 和 To 交换空间完成释放原来的 From，原来的 From 会变成 To,To 变成 From，复制的过程中可能会出现晋升(将对象复制到老生代区域)
    有两种情况会出现晋升：新生代对象在一轮 GC 后依然存在，To 空间的使用率超过了 25%(小于 25%当 To 变成 From 的后 From 可以存入新的活动对象)
-   十三、增量标记算法在 v8 的老生代对象回收时使用，在使用标记清除算法时，分批次的去标记，可以将程序的暂停事件分成多个小段，使用户不容易感知。
